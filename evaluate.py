import argparseimport torchimport torch.nn as nnimport torch.nn.functional as Fimport torch.optim as optimimport torchvisionimport torchvision.transforms as transformsimport torchvision.datasets as datasetsimport torch.utils.data.dataloaderfrom PIL import Imageimport osimport randomimport numpy as npfrom torch.autograd import Variableclass_to_idx = dict({'rests': 0, 'shelf': 1, 'shop': 2})def parse_args():    parser = argparse.ArgumentParser(description='Train a detector')    parser.add_argument('image', type=str, help='image path')    parser.add_argument('model', type=str, help='model path')    parser.add_argument(        '--resume_from', help='the checkpoint file to resume from')    parser.add_argument(        '--validate',        action='store_true',        help='whether to evaluate the checkpoint during training')    parser.add_argument(        '--gpus',        type=int,        default=1,        help='number of gpus to use '        '(only applicable to non-distributed training)')    parser.add_argument('--seed', type=int, default=None, help='random seed')    parser.add_argument(        '--launcher',        choices=['none', 'pytorch', 'slurm', 'mpi'],        default='none',        help='job launcher')    parser.add_argument('--local_rank', type=int, default=0)    args = parser.parse_args()    return argsdef main():    args = parse_args()    img_transforms = transforms.Compose([        transforms.CenterCrop((224, 224)),        transforms.ToTensor(),        transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225))    ])    img = Image.open(args.image)    if img is None:        print("Image %s not found.\n" % args.image)        return    image_tensor = img_transforms(img).float()    image_tensor = image_tensor.unsqueeze_(0)    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")    image_tensor.to(device)    input = Variable(image_tensor).to(device)    import torchvision.models as models    model = models.resnet18(pretrained=False).to(device)    model.fc = nn.Linear(in_features=512, out_features=3).to(device)    for param in model.parameters():        param.requires_grad = False    model.load_state_dict(torch.load(args.model))    output = model(input)    result = output.data.cpu().numpy().argmax()    idx_to_class = dict(zip(class_to_idx.values(), class_to_idx.keys()))    print(idx_to_class[result])if __name__ == "__main__":    main()